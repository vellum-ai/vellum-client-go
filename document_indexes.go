// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	core "github.com/vellum-ai/vellum-client-go/core"
	time "time"
)

type AddDocumentRequest struct {
}

type DocumentIndexCreateRequest struct {
	// A human-readable label for the document index
	Label string `json:"label" url:"-"`
	// A name that uniquely identifies this index within its workspace
	Name string `json:"name" url:"-"`
	// The current status of the document index
	//
	// * `ACTIVE` - Active
	// * `ARCHIVED` - Archived
	Status         *EntityStatus                       `json:"status,omitempty" url:"-"`
	IndexingConfig *DocumentIndexIndexingConfigRequest `json:"indexing_config,omitempty" url:"-"`
	// Optionally specify the id of a document index from which you'd like to copy and re-index its documents into this newly created index
	CopyDocumentsFromIndexID *string `json:"copy_documents_from_index_id,omitempty" url:"-"`
}

type DocumentIndexesDestroyRequest struct {
}

type DocumentIndexesListRequest struct {
	// Number of results to return per page.
	Limit *int `json:"-" url:"limit,omitempty"`
	// The initial index from which to return the results.
	Offset *int `json:"-" url:"offset,omitempty"`
	// Which field to use when ordering the results.
	Ordering *string `json:"-" url:"ordering,omitempty"`
	// Search for document indices by name or label
	Search *string `json:"-" url:"search,omitempty"`
	// Filter down to only document indices that have a status matching the status specified
	//
	// * `ACTIVE` - Active
	// * `ARCHIVED` - Archived
	Status *DocumentIndexesListRequestStatus `json:"-" url:"status,omitempty"`
}

type PatchedDocumentIndexUpdateRequest struct {
	// A human-readable label for the document index
	Label *string `json:"label,omitempty" url:"-"`
	// The current status of the document index
	//
	// * `ACTIVE` - Active
	// * `ARCHIVED` - Archived
	Status *EntityStatus `json:"status,omitempty" url:"-"`
}

type RemoveDocumentRequest struct {
}

type DocumentIndexesRetrieveRequest struct {
	// Whether to mask the indexing configuration in the response
	MaskIndexingConfig *bool `json:"-" url:"mask_indexing_config,omitempty"`
}

// Basic vectorizer for intfloat/multilingual-e5-large.
type BasicVectorizerIntfloatMultilingualE5LargeRequest struct {
	Config map[string]interface{} `json:"config,omitempty" url:"config,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BasicVectorizerIntfloatMultilingualE5LargeRequest) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BasicVectorizerIntfloatMultilingualE5LargeRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler BasicVectorizerIntfloatMultilingualE5LargeRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BasicVectorizerIntfloatMultilingualE5LargeRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BasicVectorizerIntfloatMultilingualE5LargeRequest) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Basic vectorizer for sentence-transformers/multi-qa-mpnet-base-cos-v1.
type BasicVectorizerSentenceTransformersMultiQaMpnetBaseCosV1Request struct {
	Config map[string]interface{} `json:"config,omitempty" url:"config,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BasicVectorizerSentenceTransformersMultiQaMpnetBaseCosV1Request) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BasicVectorizerSentenceTransformersMultiQaMpnetBaseCosV1Request) UnmarshalJSON(data []byte) error {
	type unmarshaler BasicVectorizerSentenceTransformersMultiQaMpnetBaseCosV1Request
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BasicVectorizerSentenceTransformersMultiQaMpnetBaseCosV1Request(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BasicVectorizerSentenceTransformersMultiQaMpnetBaseCosV1Request) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Basic vectorizer for sentence-transformers/multi-qa-mpnet-base-dot-v1.
type BasicVectorizerSentenceTransformersMultiQaMpnetBaseDotV1Request struct {
	Config map[string]interface{} `json:"config,omitempty" url:"config,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *BasicVectorizerSentenceTransformersMultiQaMpnetBaseDotV1Request) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BasicVectorizerSentenceTransformersMultiQaMpnetBaseDotV1Request) UnmarshalJSON(data []byte) error {
	type unmarshaler BasicVectorizerSentenceTransformersMultiQaMpnetBaseDotV1Request
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BasicVectorizerSentenceTransformersMultiQaMpnetBaseDotV1Request(value)

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *BasicVectorizerSentenceTransformersMultiQaMpnetBaseDotV1Request) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type DelimiterChunkerConfigRequest struct {
	Delimiter *string `json:"delimiter,omitempty" url:"delimiter,omitempty"`
	IsRegex   *bool   `json:"is_regex,omitempty" url:"is_regex,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DelimiterChunkerConfigRequest) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DelimiterChunkerConfigRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler DelimiterChunkerConfigRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DelimiterChunkerConfigRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DelimiterChunkerConfigRequest) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DelimiterChunkingRequest struct {
	ChunkerConfig *DelimiterChunkerConfigRequest `json:"chunker_config,omitempty" url:"chunker_config,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DelimiterChunkingRequest) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DelimiterChunkingRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler DelimiterChunkingRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DelimiterChunkingRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DelimiterChunkingRequest) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DocumentIndexChunkingRequest struct {
	ChunkerName                   string
	ReductoChunker                *ReductoChunkingRequest
	SentenceChunker               *SentenceChunkingRequest
	TokenOverlappingWindowChunker *TokenOverlappingWindowChunkingRequest
	DelimiterChunker              *DelimiterChunkingRequest
}

func (d *DocumentIndexChunkingRequest) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		ChunkerName string `json:"chunker_name"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	d.ChunkerName = unmarshaler.ChunkerName
	if unmarshaler.ChunkerName == "" {
		return fmt.Errorf("%T did not include discriminant chunker_name", d)
	}
	switch unmarshaler.ChunkerName {
	case "reducto-chunker":
		value := new(ReductoChunkingRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		d.ReductoChunker = value
	case "sentence-chunker":
		value := new(SentenceChunkingRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		d.SentenceChunker = value
	case "token-overlapping-window-chunker":
		value := new(TokenOverlappingWindowChunkingRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		d.TokenOverlappingWindowChunker = value
	case "delimiter-chunker":
		value := new(DelimiterChunkingRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		d.DelimiterChunker = value
	}
	return nil
}

func (d DocumentIndexChunkingRequest) MarshalJSON() ([]byte, error) {
	if d.ReductoChunker != nil {
		return core.MarshalJSONWithExtraProperty(d.ReductoChunker, "chunker_name", "reducto-chunker")
	}
	if d.SentenceChunker != nil {
		return core.MarshalJSONWithExtraProperty(d.SentenceChunker, "chunker_name", "sentence-chunker")
	}
	if d.TokenOverlappingWindowChunker != nil {
		return core.MarshalJSONWithExtraProperty(d.TokenOverlappingWindowChunker, "chunker_name", "token-overlapping-window-chunker")
	}
	if d.DelimiterChunker != nil {
		return core.MarshalJSONWithExtraProperty(d.DelimiterChunker, "chunker_name", "delimiter-chunker")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", d)
}

type DocumentIndexChunkingRequestVisitor interface {
	VisitReductoChunker(*ReductoChunkingRequest) error
	VisitSentenceChunker(*SentenceChunkingRequest) error
	VisitTokenOverlappingWindowChunker(*TokenOverlappingWindowChunkingRequest) error
	VisitDelimiterChunker(*DelimiterChunkingRequest) error
}

func (d *DocumentIndexChunkingRequest) Accept(visitor DocumentIndexChunkingRequestVisitor) error {
	if d.ReductoChunker != nil {
		return visitor.VisitReductoChunker(d.ReductoChunker)
	}
	if d.SentenceChunker != nil {
		return visitor.VisitSentenceChunker(d.SentenceChunker)
	}
	if d.TokenOverlappingWindowChunker != nil {
		return visitor.VisitTokenOverlappingWindowChunker(d.TokenOverlappingWindowChunker)
	}
	if d.DelimiterChunker != nil {
		return visitor.VisitDelimiterChunker(d.DelimiterChunker)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", d)
}

type DocumentIndexIndexingConfigRequest struct {
	Vectorizer *IndexingConfigVectorizerRequest `json:"vectorizer" url:"vectorizer"`
	Chunking   *DocumentIndexChunkingRequest    `json:"chunking,omitempty" url:"chunking,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DocumentIndexIndexingConfigRequest) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DocumentIndexIndexingConfigRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler DocumentIndexIndexingConfigRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DocumentIndexIndexingConfigRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DocumentIndexIndexingConfigRequest) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DocumentIndexRead struct {
	ID      string    `json:"id" url:"id"`
	Created time.Time `json:"created" url:"created"`
	// A human-readable label for the document index
	Label string `json:"label" url:"label"`
	// A name that uniquely identifies this index within its workspace
	Name string `json:"name" url:"name"`
	// The current status of the document index
	//
	// * `ACTIVE` - Active
	// * `ARCHIVED` - Archived
	Status         *EntityStatus                `json:"status,omitempty" url:"status,omitempty"`
	IndexingConfig *DocumentIndexIndexingConfig `json:"indexing_config" url:"indexing_config"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DocumentIndexRead) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DocumentIndexRead) UnmarshalJSON(data []byte) error {
	type embed DocumentIndexRead
	var unmarshaler = struct {
		embed
		Created *core.DateTime `json:"created"`
	}{
		embed: embed(*d),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*d = DocumentIndexRead(unmarshaler.embed)
	d.Created = unmarshaler.Created.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DocumentIndexRead) MarshalJSON() ([]byte, error) {
	type embed DocumentIndexRead
	var marshaler = struct {
		embed
		Created *core.DateTime `json:"created"`
	}{
		embed:   embed(*d),
		Created: core.NewDateTime(d.Created),
	}
	return json.Marshal(marshaler)
}

func (d *DocumentIndexRead) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// FastEmbed vectorizer for BAAI/bge-small-en-v1.5.
type FastEmbedVectorizerBaaiBgeSmallEnV15Request struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (f *FastEmbedVectorizerBaaiBgeSmallEnV15Request) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FastEmbedVectorizerBaaiBgeSmallEnV15Request) UnmarshalJSON(data []byte) error {
	type unmarshaler FastEmbedVectorizerBaaiBgeSmallEnV15Request
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FastEmbedVectorizerBaaiBgeSmallEnV15Request(value)

	extraProperties, err := core.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties

	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FastEmbedVectorizerBaaiBgeSmallEnV15Request) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type GoogleVertexAiVectorizerConfigRequest struct {
	ProjectID string `json:"project_id" url:"project_id"`
	Region    string `json:"region" url:"region"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GoogleVertexAiVectorizerConfigRequest) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GoogleVertexAiVectorizerConfigRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GoogleVertexAiVectorizerConfigRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GoogleVertexAiVectorizerConfigRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GoogleVertexAiVectorizerConfigRequest) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GoogleVertexAiVectorizerGeminiEmbedding001Request struct {
	Config *GoogleVertexAiVectorizerConfigRequest `json:"config" url:"config"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GoogleVertexAiVectorizerGeminiEmbedding001Request) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GoogleVertexAiVectorizerGeminiEmbedding001Request) UnmarshalJSON(data []byte) error {
	type unmarshaler GoogleVertexAiVectorizerGeminiEmbedding001Request
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GoogleVertexAiVectorizerGeminiEmbedding001Request(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GoogleVertexAiVectorizerGeminiEmbedding001Request) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GoogleVertexAiVectorizerTextEmbedding004Request struct {
	Config *GoogleVertexAiVectorizerConfigRequest `json:"config" url:"config"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GoogleVertexAiVectorizerTextEmbedding004Request) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GoogleVertexAiVectorizerTextEmbedding004Request) UnmarshalJSON(data []byte) error {
	type unmarshaler GoogleVertexAiVectorizerTextEmbedding004Request
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GoogleVertexAiVectorizerTextEmbedding004Request(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GoogleVertexAiVectorizerTextEmbedding004Request) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GoogleVertexAiVectorizerTextMultilingualEmbedding002Request struct {
	Config *GoogleVertexAiVectorizerConfigRequest `json:"config" url:"config"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GoogleVertexAiVectorizerTextMultilingualEmbedding002Request) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GoogleVertexAiVectorizerTextMultilingualEmbedding002Request) UnmarshalJSON(data []byte) error {
	type unmarshaler GoogleVertexAiVectorizerTextMultilingualEmbedding002Request
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GoogleVertexAiVectorizerTextMultilingualEmbedding002Request(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GoogleVertexAiVectorizerTextMultilingualEmbedding002Request) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Vectorizer for hkunlp/instructor-xl.
type HkunlpInstructorXlVectorizerRequest struct {
	Config *InstructorVectorizerConfigRequest `json:"config" url:"config"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (h *HkunlpInstructorXlVectorizerRequest) GetExtraProperties() map[string]interface{} {
	return h.extraProperties
}

func (h *HkunlpInstructorXlVectorizerRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler HkunlpInstructorXlVectorizerRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HkunlpInstructorXlVectorizerRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *h)
	if err != nil {
		return err
	}
	h.extraProperties = extraProperties

	h._rawJSON = json.RawMessage(data)
	return nil
}

func (h *HkunlpInstructorXlVectorizerRequest) String() string {
	if len(h._rawJSON) > 0 {
		if value, err := core.StringifyJSON(h._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

type IndexingConfigVectorizerRequest struct {
	ModelName                                 string
	TextEmbedding3Small                       *OpenAiVectorizerTextEmbedding3SmallRequest
	TextEmbedding3Large                       *OpenAiVectorizerTextEmbedding3LargeRequest
	TextEmbeddingAda002                       *OpenAiVectorizerTextEmbeddingAda002Request
	IntfloatMultilingualE5Large               *BasicVectorizerIntfloatMultilingualE5LargeRequest
	SentenceTransformersMultiQaMpnetBaseCosV1 *BasicVectorizerSentenceTransformersMultiQaMpnetBaseCosV1Request
	SentenceTransformersMultiQaMpnetBaseDotV1 *BasicVectorizerSentenceTransformersMultiQaMpnetBaseDotV1Request
	HkunlpInstructorXl                        *HkunlpInstructorXlVectorizerRequest
	TextEmbedding004                          *GoogleVertexAiVectorizerTextEmbedding004Request
	TextMultilingualEmbedding002              *GoogleVertexAiVectorizerTextMultilingualEmbedding002Request
	GeminiEmbedding001                        *GoogleVertexAiVectorizerGeminiEmbedding001Request
	BaaiBgeSmallEnV15                         *FastEmbedVectorizerBaaiBgeSmallEnV15Request
	PrivateVectorizer                         *PrivateVectorizerRequest
}

func (i *IndexingConfigVectorizerRequest) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		ModelName string `json:"model_name"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	i.ModelName = unmarshaler.ModelName
	if unmarshaler.ModelName == "" {
		return fmt.Errorf("%T did not include discriminant model_name", i)
	}
	switch unmarshaler.ModelName {
	case "text-embedding-3-small":
		value := new(OpenAiVectorizerTextEmbedding3SmallRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		i.TextEmbedding3Small = value
	case "text-embedding-3-large":
		value := new(OpenAiVectorizerTextEmbedding3LargeRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		i.TextEmbedding3Large = value
	case "text-embedding-ada-002":
		value := new(OpenAiVectorizerTextEmbeddingAda002Request)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		i.TextEmbeddingAda002 = value
	case "intfloat/multilingual-e5-large":
		value := new(BasicVectorizerIntfloatMultilingualE5LargeRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		i.IntfloatMultilingualE5Large = value
	case "sentence-transformers/multi-qa-mpnet-base-cos-v1":
		value := new(BasicVectorizerSentenceTransformersMultiQaMpnetBaseCosV1Request)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		i.SentenceTransformersMultiQaMpnetBaseCosV1 = value
	case "sentence-transformers/multi-qa-mpnet-base-dot-v1":
		value := new(BasicVectorizerSentenceTransformersMultiQaMpnetBaseDotV1Request)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		i.SentenceTransformersMultiQaMpnetBaseDotV1 = value
	case "hkunlp/instructor-xl":
		value := new(HkunlpInstructorXlVectorizerRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		i.HkunlpInstructorXl = value
	case "text-embedding-004":
		value := new(GoogleVertexAiVectorizerTextEmbedding004Request)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		i.TextEmbedding004 = value
	case "text-multilingual-embedding-002":
		value := new(GoogleVertexAiVectorizerTextMultilingualEmbedding002Request)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		i.TextMultilingualEmbedding002 = value
	case "gemini-embedding-001":
		value := new(GoogleVertexAiVectorizerGeminiEmbedding001Request)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		i.GeminiEmbedding001 = value
	case "BAAI/bge-small-en-v1.5":
		value := new(FastEmbedVectorizerBaaiBgeSmallEnV15Request)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		i.BaaiBgeSmallEnV15 = value
	case "private-vectorizer":
		value := new(PrivateVectorizerRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		i.PrivateVectorizer = value
	}
	return nil
}

func (i IndexingConfigVectorizerRequest) MarshalJSON() ([]byte, error) {
	if i.TextEmbedding3Small != nil {
		return core.MarshalJSONWithExtraProperty(i.TextEmbedding3Small, "model_name", "text-embedding-3-small")
	}
	if i.TextEmbedding3Large != nil {
		return core.MarshalJSONWithExtraProperty(i.TextEmbedding3Large, "model_name", "text-embedding-3-large")
	}
	if i.TextEmbeddingAda002 != nil {
		return core.MarshalJSONWithExtraProperty(i.TextEmbeddingAda002, "model_name", "text-embedding-ada-002")
	}
	if i.IntfloatMultilingualE5Large != nil {
		return core.MarshalJSONWithExtraProperty(i.IntfloatMultilingualE5Large, "model_name", "intfloat/multilingual-e5-large")
	}
	if i.SentenceTransformersMultiQaMpnetBaseCosV1 != nil {
		return core.MarshalJSONWithExtraProperty(i.SentenceTransformersMultiQaMpnetBaseCosV1, "model_name", "sentence-transformers/multi-qa-mpnet-base-cos-v1")
	}
	if i.SentenceTransformersMultiQaMpnetBaseDotV1 != nil {
		return core.MarshalJSONWithExtraProperty(i.SentenceTransformersMultiQaMpnetBaseDotV1, "model_name", "sentence-transformers/multi-qa-mpnet-base-dot-v1")
	}
	if i.HkunlpInstructorXl != nil {
		return core.MarshalJSONWithExtraProperty(i.HkunlpInstructorXl, "model_name", "hkunlp/instructor-xl")
	}
	if i.TextEmbedding004 != nil {
		return core.MarshalJSONWithExtraProperty(i.TextEmbedding004, "model_name", "text-embedding-004")
	}
	if i.TextMultilingualEmbedding002 != nil {
		return core.MarshalJSONWithExtraProperty(i.TextMultilingualEmbedding002, "model_name", "text-multilingual-embedding-002")
	}
	if i.GeminiEmbedding001 != nil {
		return core.MarshalJSONWithExtraProperty(i.GeminiEmbedding001, "model_name", "gemini-embedding-001")
	}
	if i.BaaiBgeSmallEnV15 != nil {
		return core.MarshalJSONWithExtraProperty(i.BaaiBgeSmallEnV15, "model_name", "BAAI/bge-small-en-v1.5")
	}
	if i.PrivateVectorizer != nil {
		return core.MarshalJSONWithExtraProperty(i.PrivateVectorizer, "model_name", "private-vectorizer")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", i)
}

type IndexingConfigVectorizerRequestVisitor interface {
	VisitTextEmbedding3Small(*OpenAiVectorizerTextEmbedding3SmallRequest) error
	VisitTextEmbedding3Large(*OpenAiVectorizerTextEmbedding3LargeRequest) error
	VisitTextEmbeddingAda002(*OpenAiVectorizerTextEmbeddingAda002Request) error
	VisitIntfloatMultilingualE5Large(*BasicVectorizerIntfloatMultilingualE5LargeRequest) error
	VisitSentenceTransformersMultiQaMpnetBaseCosV1(*BasicVectorizerSentenceTransformersMultiQaMpnetBaseCosV1Request) error
	VisitSentenceTransformersMultiQaMpnetBaseDotV1(*BasicVectorizerSentenceTransformersMultiQaMpnetBaseDotV1Request) error
	VisitHkunlpInstructorXl(*HkunlpInstructorXlVectorizerRequest) error
	VisitTextEmbedding004(*GoogleVertexAiVectorizerTextEmbedding004Request) error
	VisitTextMultilingualEmbedding002(*GoogleVertexAiVectorizerTextMultilingualEmbedding002Request) error
	VisitGeminiEmbedding001(*GoogleVertexAiVectorizerGeminiEmbedding001Request) error
	VisitBaaiBgeSmallEnV15(*FastEmbedVectorizerBaaiBgeSmallEnV15Request) error
	VisitPrivateVectorizer(*PrivateVectorizerRequest) error
}

func (i *IndexingConfigVectorizerRequest) Accept(visitor IndexingConfigVectorizerRequestVisitor) error {
	if i.TextEmbedding3Small != nil {
		return visitor.VisitTextEmbedding3Small(i.TextEmbedding3Small)
	}
	if i.TextEmbedding3Large != nil {
		return visitor.VisitTextEmbedding3Large(i.TextEmbedding3Large)
	}
	if i.TextEmbeddingAda002 != nil {
		return visitor.VisitTextEmbeddingAda002(i.TextEmbeddingAda002)
	}
	if i.IntfloatMultilingualE5Large != nil {
		return visitor.VisitIntfloatMultilingualE5Large(i.IntfloatMultilingualE5Large)
	}
	if i.SentenceTransformersMultiQaMpnetBaseCosV1 != nil {
		return visitor.VisitSentenceTransformersMultiQaMpnetBaseCosV1(i.SentenceTransformersMultiQaMpnetBaseCosV1)
	}
	if i.SentenceTransformersMultiQaMpnetBaseDotV1 != nil {
		return visitor.VisitSentenceTransformersMultiQaMpnetBaseDotV1(i.SentenceTransformersMultiQaMpnetBaseDotV1)
	}
	if i.HkunlpInstructorXl != nil {
		return visitor.VisitHkunlpInstructorXl(i.HkunlpInstructorXl)
	}
	if i.TextEmbedding004 != nil {
		return visitor.VisitTextEmbedding004(i.TextEmbedding004)
	}
	if i.TextMultilingualEmbedding002 != nil {
		return visitor.VisitTextMultilingualEmbedding002(i.TextMultilingualEmbedding002)
	}
	if i.GeminiEmbedding001 != nil {
		return visitor.VisitGeminiEmbedding001(i.GeminiEmbedding001)
	}
	if i.BaaiBgeSmallEnV15 != nil {
		return visitor.VisitBaaiBgeSmallEnV15(i.BaaiBgeSmallEnV15)
	}
	if i.PrivateVectorizer != nil {
		return visitor.VisitPrivateVectorizer(i.PrivateVectorizer)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", i)
}

// Configuration for using an Instructor vectorizer.
type InstructorVectorizerConfigRequest struct {
	InstructionDomain           string `json:"instruction_domain" url:"instruction_domain"`
	InstructionQueryTextType    string `json:"instruction_query_text_type" url:"instruction_query_text_type"`
	InstructionDocumentTextType string `json:"instruction_document_text_type" url:"instruction_document_text_type"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *InstructorVectorizerConfigRequest) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InstructorVectorizerConfigRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler InstructorVectorizerConfigRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InstructorVectorizerConfigRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *InstructorVectorizerConfigRequest) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// Configuration for using an OpenAI vectorizer.
type OpenAiVectorizerConfigRequest struct {
	AddOpenaiAPIKey *AddOpenaiAPIKeyEnum `json:"add_openai_api_key,omitempty" url:"add_openai_api_key,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OpenAiVectorizerConfigRequest) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OpenAiVectorizerConfigRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler OpenAiVectorizerConfigRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OpenAiVectorizerConfigRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OpenAiVectorizerConfigRequest) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// OpenAI vectorizer for text-embedding-3-large.
type OpenAiVectorizerTextEmbedding3LargeRequest struct {
	Config *OpenAiVectorizerConfigRequest `json:"config" url:"config"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OpenAiVectorizerTextEmbedding3LargeRequest) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OpenAiVectorizerTextEmbedding3LargeRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler OpenAiVectorizerTextEmbedding3LargeRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OpenAiVectorizerTextEmbedding3LargeRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OpenAiVectorizerTextEmbedding3LargeRequest) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// OpenAI vectorizer for text-embedding-3-small.
type OpenAiVectorizerTextEmbedding3SmallRequest struct {
	Config *OpenAiVectorizerConfigRequest `json:"config" url:"config"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OpenAiVectorizerTextEmbedding3SmallRequest) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OpenAiVectorizerTextEmbedding3SmallRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler OpenAiVectorizerTextEmbedding3SmallRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OpenAiVectorizerTextEmbedding3SmallRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OpenAiVectorizerTextEmbedding3SmallRequest) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

// OpenAI vectorizer for text-embedding-ada-002.
type OpenAiVectorizerTextEmbeddingAda002Request struct {
	Config *OpenAiVectorizerConfigRequest `json:"config" url:"config"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (o *OpenAiVectorizerTextEmbeddingAda002Request) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OpenAiVectorizerTextEmbeddingAda002Request) UnmarshalJSON(data []byte) error {
	type unmarshaler OpenAiVectorizerTextEmbeddingAda002Request
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OpenAiVectorizerTextEmbeddingAda002Request(value)

	extraProperties, err := core.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties

	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OpenAiVectorizerTextEmbeddingAda002Request) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type PaginatedDocumentIndexReadList struct {
	Count    *int                 `json:"count,omitempty" url:"count,omitempty"`
	Next     *string              `json:"next,omitempty" url:"next,omitempty"`
	Previous *string              `json:"previous,omitempty" url:"previous,omitempty"`
	Results  []*DocumentIndexRead `json:"results,omitempty" url:"results,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaginatedDocumentIndexReadList) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaginatedDocumentIndexReadList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedDocumentIndexReadList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedDocumentIndexReadList(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedDocumentIndexReadList) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Serializer for private vectorizer.
type PrivateVectorizerRequest struct {
	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PrivateVectorizerRequest) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PrivateVectorizerRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler PrivateVectorizerRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PrivateVectorizerRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PrivateVectorizerRequest) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// Configuration for Reducto chunking
type ReductoChunkerConfigRequest struct {
	CharacterLimit *int `json:"character_limit,omitempty" url:"character_limit,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *ReductoChunkerConfigRequest) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ReductoChunkerConfigRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ReductoChunkerConfigRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ReductoChunkerConfigRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *ReductoChunkerConfigRequest) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Reducto chunking
type ReductoChunkingRequest struct {
	ChunkerConfig *ReductoChunkerConfigRequest `json:"chunker_config,omitempty" url:"chunker_config,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *ReductoChunkingRequest) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ReductoChunkingRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ReductoChunkingRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ReductoChunkingRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *ReductoChunkingRequest) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// Configuration for sentence chunking
type SentenceChunkerConfigRequest struct {
	CharacterLimit  *int     `json:"character_limit,omitempty" url:"character_limit,omitempty"`
	MinOverlapRatio *float64 `json:"min_overlap_ratio,omitempty" url:"min_overlap_ratio,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SentenceChunkerConfigRequest) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SentenceChunkerConfigRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler SentenceChunkerConfigRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SentenceChunkerConfigRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SentenceChunkerConfigRequest) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Sentence chunking
type SentenceChunkingRequest struct {
	ChunkerConfig *SentenceChunkerConfigRequest `json:"chunker_config,omitempty" url:"chunker_config,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SentenceChunkingRequest) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SentenceChunkingRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler SentenceChunkingRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SentenceChunkingRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SentenceChunkingRequest) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Configuration for token overlapping window chunking
type TokenOverlappingWindowChunkerConfigRequest struct {
	TokenLimit   *int     `json:"token_limit,omitempty" url:"token_limit,omitempty"`
	OverlapRatio *float64 `json:"overlap_ratio,omitempty" url:"overlap_ratio,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TokenOverlappingWindowChunkerConfigRequest) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TokenOverlappingWindowChunkerConfigRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler TokenOverlappingWindowChunkerConfigRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TokenOverlappingWindowChunkerConfigRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TokenOverlappingWindowChunkerConfigRequest) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Token overlapping window chunking
type TokenOverlappingWindowChunkingRequest struct {
	ChunkerConfig *TokenOverlappingWindowChunkerConfigRequest `json:"chunker_config,omitempty" url:"chunker_config,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TokenOverlappingWindowChunkingRequest) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TokenOverlappingWindowChunkingRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler TokenOverlappingWindowChunkingRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TokenOverlappingWindowChunkingRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TokenOverlappingWindowChunkingRequest) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type DocumentIndexesListRequestStatus string

const (
	DocumentIndexesListRequestStatusActive   DocumentIndexesListRequestStatus = "ACTIVE"
	DocumentIndexesListRequestStatusArchived DocumentIndexesListRequestStatus = "ARCHIVED"
)

func NewDocumentIndexesListRequestStatusFromString(s string) (DocumentIndexesListRequestStatus, error) {
	switch s {
	case "ACTIVE":
		return DocumentIndexesListRequestStatusActive, nil
	case "ARCHIVED":
		return DocumentIndexesListRequestStatusArchived, nil
	}
	var t DocumentIndexesListRequestStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DocumentIndexesListRequestStatus) Ptr() *DocumentIndexesListRequestStatus {
	return &d
}

type DocumentIndexUpdateRequest struct {
	// A human-readable label for the document index
	Label string `json:"label" url:"-"`
	// The current status of the document index
	//
	// * `ACTIVE` - Active
	// * `ARCHIVED` - Archived
	Status *EntityStatus `json:"status,omitempty" url:"-"`
}
