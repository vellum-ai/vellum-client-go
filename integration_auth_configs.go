// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	core "github.com/vellum-ai/vellum-client-go/core"
)

type ListIntegrationAuthConfigsRequest struct {
	// The response fields to expand for more information.
	// - 'integration_credentials' expands the list of integration credentials that the authenticated entity has access to for the auth config.
	Expand              []*string `json:"-" url:"expand,omitempty"`
	IntegrationName     *string   `json:"-" url:"integration_name,omitempty"`
	IntegrationProvider *string   `json:"-" url:"integration_provider,omitempty"`
	// Number of results to return per page.
	Limit *int `json:"-" url:"limit,omitempty"`
	// The initial index from which to return the results.
	Offset *int `json:"-" url:"offset,omitempty"`
	// Which field to use when ordering the results.
	Ordering *string `json:"-" url:"ordering,omitempty"`
	// A search term.
	Search *string `json:"-" url:"search,omitempty"`
}

// * `API_KEY` - API Key
// * `OAUTH2` - OAuth2
type AuthTypeEnum string

const (
	AuthTypeEnumApiKey AuthTypeEnum = "API_KEY"
	AuthTypeEnumOauth2 AuthTypeEnum = "OAUTH2"
)

func NewAuthTypeEnumFromString(s string) (AuthTypeEnum, error) {
	switch s {
	case "API_KEY":
		return AuthTypeEnumApiKey, nil
	case "OAUTH2":
		return AuthTypeEnumOauth2, nil
	}
	var t AuthTypeEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AuthTypeEnum) Ptr() *AuthTypeEnum {
	return &a
}

type IntegrationAuthConfigIntegration struct {
	Id       string              `json:"id" url:"id"`
	Provider IntegrationProvider `json:"provider" url:"provider"`
	Name     IntegrationName     `json:"name" url:"name"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *IntegrationAuthConfigIntegration) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IntegrationAuthConfigIntegration) UnmarshalJSON(data []byte) error {
	type unmarshaler IntegrationAuthConfigIntegration
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IntegrationAuthConfigIntegration(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *IntegrationAuthConfigIntegration) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type IntegrationAuthConfigIntegrationCredential struct {
	Id string `json:"id" url:"id"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *IntegrationAuthConfigIntegrationCredential) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IntegrationAuthConfigIntegrationCredential) UnmarshalJSON(data []byte) error {
	type unmarshaler IntegrationAuthConfigIntegrationCredential
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IntegrationAuthConfigIntegrationCredential(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *IntegrationAuthConfigIntegrationCredential) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// * `ENVIRONMENT` - ENVIRONMENT
// * `USER` - USER
type IntegrationCredentialAccessType string

const (
	IntegrationCredentialAccessTypeEnvironment IntegrationCredentialAccessType = "ENVIRONMENT"
	IntegrationCredentialAccessTypeUser        IntegrationCredentialAccessType = "USER"
)

func NewIntegrationCredentialAccessTypeFromString(s string) (IntegrationCredentialAccessType, error) {
	switch s {
	case "ENVIRONMENT":
		return IntegrationCredentialAccessTypeEnvironment, nil
	case "USER":
		return IntegrationCredentialAccessTypeUser, nil
	}
	var t IntegrationCredentialAccessType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IntegrationCredentialAccessType) Ptr() *IntegrationCredentialAccessType {
	return &i
}

type PaginatedSlimIntegrationAuthConfigReadList struct {
	Count    *int                             `json:"count,omitempty" url:"count,omitempty"`
	Next     *string                          `json:"next,omitempty" url:"next,omitempty"`
	Previous *string                          `json:"previous,omitempty" url:"previous,omitempty"`
	Results  []*SlimIntegrationAuthConfigRead `json:"results,omitempty" url:"results,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaginatedSlimIntegrationAuthConfigReadList) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaginatedSlimIntegrationAuthConfigReadList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedSlimIntegrationAuthConfigReadList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedSlimIntegrationAuthConfigReadList(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedSlimIntegrationAuthConfigReadList) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// A slim representation of an Integration Auth Config.
type SlimIntegrationAuthConfigRead struct {
	Id                     string                                        `json:"id" url:"id"`
	Integration            *IntegrationAuthConfigIntegration             `json:"integration" url:"integration"`
	AuthType               *AuthTypeEnum                                 `json:"auth_type,omitempty" url:"auth_type,omitempty"`
	IntegrationCredentials []*IntegrationAuthConfigIntegrationCredential `json:"integration_credentials,omitempty" url:"integration_credentials,omitempty"`
	// Whether or not this auth config is eligible to use Vellum-managed system credentials to authenticate.
	SystemCredentialEligible *bool                            `json:"system_credential_eligible,omitempty" url:"system_credential_eligible,omitempty"`
	DefaultAccessType        *IntegrationCredentialAccessType `json:"default_access_type,omitempty" url:"default_access_type,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SlimIntegrationAuthConfigRead) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SlimIntegrationAuthConfigRead) UnmarshalJSON(data []byte) error {
	type unmarshaler SlimIntegrationAuthConfigRead
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SlimIntegrationAuthConfigRead(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SlimIntegrationAuthConfigRead) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}
