// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	core "github.com/vellum-ai/vellum-client-go/core"
	time "time"
)

type CreateContainerImageRequest struct {
	Name           string                         `json:"name" url:"-"`
	Packages       []*CodeExecutionPackageRequest `json:"packages,omitempty" url:"-"`
	Tag            string                         `json:"tag" url:"-"`
	UserScript     *string                        `json:"user_script,omitempty" url:"-"`
	IsHotswappable *bool                          `json:"is_hotswappable,omitempty" url:"-"`
	ServerVersion  *string                        `json:"server_version,omitempty" url:"-"`
}

type ContainerImagesListRequest struct {
	// Number of results to return per page.
	Limit *int `json:"-" url:"limit,omitempty"`
	// The initial index from which to return the results.
	Offset *int `json:"-" url:"offset,omitempty"`
	// Which field to use when ordering the results.
	Ordering *string `json:"-" url:"ordering,omitempty"`
}

type PushContainerImageRequest struct {
	Name  string   `json:"name" url:"-"`
	Sha   string   `json:"sha" url:"-"`
	Tags  []string `json:"tags,omitempty" url:"-"`
	Force *bool    `json:"force,omitempty" url:"-"`
}

type ContainerImagesRetrieveRequest struct {
}

// * `QUEUED` - Queued
// * `BUILDING` - Building
// * `AVAILABLE` - Available
// * `FAILED` - Failed
// * `UNKNOWN` - Unknown
type BuildStatusEnum string

const (
	BuildStatusEnumQueued    BuildStatusEnum = "QUEUED"
	BuildStatusEnumBuilding  BuildStatusEnum = "BUILDING"
	BuildStatusEnumAvailable BuildStatusEnum = "AVAILABLE"
	BuildStatusEnumFailed    BuildStatusEnum = "FAILED"
	BuildStatusEnumUnknown   BuildStatusEnum = "UNKNOWN"
)

func NewBuildStatusEnumFromString(s string) (BuildStatusEnum, error) {
	switch s {
	case "QUEUED":
		return BuildStatusEnumQueued, nil
	case "BUILDING":
		return BuildStatusEnumBuilding, nil
	case "AVAILABLE":
		return BuildStatusEnumAvailable, nil
	case "FAILED":
		return BuildStatusEnumFailed, nil
	case "UNKNOWN":
		return BuildStatusEnumUnknown, nil
	}
	var t BuildStatusEnum
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BuildStatusEnum) Ptr() *BuildStatusEnum {
	return &b
}

type CodeExecutionPackageRequest struct {
	Version    string  `json:"version" url:"version"`
	Name       string  `json:"name" url:"name"`
	Repository *string `json:"repository,omitempty" url:"repository,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CodeExecutionPackageRequest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CodeExecutionPackageRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler CodeExecutionPackageRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CodeExecutionPackageRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CodeExecutionPackageRequest) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ContainerImageBuildConfig struct {
	Packages            []*CodeExecutionPackage `json:"packages" url:"packages"`
	UserScript          *string                 `json:"user_script,omitempty" url:"user_script,omitempty"`
	HotswappableVersion *string                 `json:"hotswappable_version,omitempty" url:"hotswappable_version,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ContainerImageBuildConfig) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ContainerImageBuildConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler ContainerImageBuildConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ContainerImageBuildConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ContainerImageBuildConfig) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ContainerImageContainerImageTag struct {
	Name           string    `json:"name" url:"name"`
	Modified       time.Time `json:"modified" url:"modified"`
	HistoryItemSha *string   `json:"history_item_sha,omitempty" url:"history_item_sha,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ContainerImageContainerImageTag) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ContainerImageContainerImageTag) UnmarshalJSON(data []byte) error {
	type embed ContainerImageContainerImageTag
	var unmarshaler = struct {
		embed
		Modified *core.DateTime `json:"modified"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ContainerImageContainerImageTag(unmarshaler.embed)
	c.Modified = unmarshaler.Modified.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ContainerImageContainerImageTag) MarshalJSON() ([]byte, error) {
	type embed ContainerImageContainerImageTag
	var marshaler = struct {
		embed
		Modified *core.DateTime `json:"modified"`
	}{
		embed:    embed(*c),
		Modified: core.NewDateTime(c.Modified),
	}
	return json.Marshal(marshaler)
}

func (c *ContainerImageContainerImageTag) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ContainerImageRead struct {
	ID          string                             `json:"id" url:"id"`
	Name        string                             `json:"name" url:"name"`
	Visibility  EntityVisibility                   `json:"visibility" url:"visibility"`
	Created     time.Time                          `json:"created" url:"created"`
	Modified    time.Time                          `json:"modified" url:"modified"`
	Repository  string                             `json:"repository" url:"repository"`
	Sha         string                             `json:"sha" url:"sha"`
	Tags        []*ContainerImageContainerImageTag `json:"tags" url:"tags"`
	BuildStatus *BuildStatusEnum                   `json:"build_status,omitempty" url:"build_status,omitempty"`
	BuildConfig *ContainerImageBuildConfig         `json:"build_config,omitempty" url:"build_config,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ContainerImageRead) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ContainerImageRead) UnmarshalJSON(data []byte) error {
	type embed ContainerImageRead
	var unmarshaler = struct {
		embed
		Created  *core.DateTime `json:"created"`
		Modified *core.DateTime `json:"modified"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ContainerImageRead(unmarshaler.embed)
	c.Created = unmarshaler.Created.Time()
	c.Modified = unmarshaler.Modified.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ContainerImageRead) MarshalJSON() ([]byte, error) {
	type embed ContainerImageRead
	var marshaler = struct {
		embed
		Created  *core.DateTime `json:"created"`
		Modified *core.DateTime `json:"modified"`
	}{
		embed:    embed(*c),
		Created:  core.NewDateTime(c.Created),
		Modified: core.NewDateTime(c.Modified),
	}
	return json.Marshal(marshaler)
}

func (c *ContainerImageRead) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type DockerServiceToken struct {
	AccessToken    string `json:"access_token" url:"access_token"`
	OrganizationID string `json:"organization_id" url:"organization_id"`
	Repository     string `json:"repository" url:"repository"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (d *DockerServiceToken) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DockerServiceToken) UnmarshalJSON(data []byte) error {
	type unmarshaler DockerServiceToken
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DockerServiceToken(value)

	extraProperties, err := core.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DockerServiceToken) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// * `DEFAULT` - Default
// * `PUBLIC` - Public
// * `PRIVATE` - Private
// * `DISABLED` - Disabled
type EntityVisibility string

const (
	EntityVisibilityDefault  EntityVisibility = "DEFAULT"
	EntityVisibilityPublic   EntityVisibility = "PUBLIC"
	EntityVisibilityPrivate  EntityVisibility = "PRIVATE"
	EntityVisibilityDisabled EntityVisibility = "DISABLED"
)

func NewEntityVisibilityFromString(s string) (EntityVisibility, error) {
	switch s {
	case "DEFAULT":
		return EntityVisibilityDefault, nil
	case "PUBLIC":
		return EntityVisibilityPublic, nil
	case "PRIVATE":
		return EntityVisibilityPrivate, nil
	case "DISABLED":
		return EntityVisibilityDisabled, nil
	}
	var t EntityVisibility
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EntityVisibility) Ptr() *EntityVisibility {
	return &e
}

type PaginatedContainerImageReadList struct {
	Count    *int                  `json:"count,omitempty" url:"count,omitempty"`
	Next     *string               `json:"next,omitempty" url:"next,omitempty"`
	Previous *string               `json:"previous,omitempty" url:"previous,omitempty"`
	Results  []*ContainerImageRead `json:"results,omitempty" url:"results,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaginatedContainerImageReadList) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaginatedContainerImageReadList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedContainerImageReadList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedContainerImageReadList(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedContainerImageReadList) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type UpdateContainerImageRequest struct {
	Packages       []*CodeExecutionPackageRequest `json:"packages,omitempty" url:"-"`
	Tag            string                         `json:"tag" url:"-"`
	UserScript     *string                        `json:"user_script,omitempty" url:"-"`
	IsHotswappable *bool                          `json:"is_hotswappable,omitempty" url:"-"`
	ServerVersion  *string                        `json:"server_version,omitempty" url:"-"`
}
