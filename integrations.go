// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	core "github.com/vellum-ai/vellum-client-go/core"
)

type ExecuteIntegrationToolRequest struct {
	Body *ExecuteToolRequest `json:"-" url:"-"`
}

func (e *ExecuteIntegrationToolRequest) UnmarshalJSON(data []byte) error {
	body := new(ExecuteToolRequest)
	if err := json.Unmarshal(data, &body); err != nil {
		return err
	}
	e.Body = body
	return nil
}

func (e *ExecuteIntegrationToolRequest) MarshalJSON() ([]byte, error) {
	return json.Marshal(e.Body)
}

type IntegrationsListRequest struct {
	// * `COMPOSIO` - Composio
	IntegrationProvider *IntegrationsListRequestIntegrationProvider `json:"-" url:"integration_provider,omitempty"`
	// Number of results to return per page.
	Limit *int `json:"-" url:"limit,omitempty"`
	// The initial index from which to return the results.
	Offset *int `json:"-" url:"offset,omitempty"`
	// Which field to use when ordering the results.
	Ordering *string `json:"-" url:"ordering,omitempty"`
	// A search term.
	Search                      *string `json:"-" url:"search,omitempty"`
	SupportsIntegrationTriggers *string `json:"-" url:"supports_integration_triggers,omitempty"`
}

type IntegrationsRetrieveRequest struct {
}

type RetrieveIntegrationToolDefinitionRequest struct {
	// The version of the toolkit to use. Pass 'latest' to get the latest version, or a specific version string to pin it. If not provided, uses the provider's default.
	ToolkitVersion *string `json:"-" url:"toolkit_version,omitempty"`
}

// Payload for executing a Composio tool with provider id and tool arguments.
type ComposioExecuteToolRequest struct {
	Arguments      map[string]interface{} `json:"arguments" url:"arguments"`
	ToolkitVersion *string                `json:"toolkit_version,omitempty" url:"toolkit_version,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ComposioExecuteToolRequest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ComposioExecuteToolRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ComposioExecuteToolRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ComposioExecuteToolRequest(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ComposioExecuteToolRequest) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Response payload with provider id and execution output from a Composio tool.
type ComposioExecuteToolResponse struct {
	Data map[string]interface{} `json:"data" url:"data"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ComposioExecuteToolResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ComposioExecuteToolResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ComposioExecuteToolResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ComposioExecuteToolResponse(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ComposioExecuteToolResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ComposioIntegrationExecConfig struct {
	Slug                    string `json:"slug" url:"slug"`
	SupportsWebhookTriggers *bool  `json:"supports_webhook_triggers,omitempty" url:"supports_webhook_triggers,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *ComposioIntegrationExecConfig) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ComposioIntegrationExecConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler ComposioIntegrationExecConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ComposioIntegrationExecConfig(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ComposioIntegrationExecConfig) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ExecuteToolRequest struct {
	Provider string
	Composio *ComposioExecuteToolRequest
}

func (e *ExecuteToolRequest) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Provider string `json:"provider"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Provider = unmarshaler.Provider
	if unmarshaler.Provider == "" {
		return fmt.Errorf("%T did not include discriminant provider", e)
	}
	switch unmarshaler.Provider {
	case "COMPOSIO":
		value := new(ComposioExecuteToolRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Composio = value
	}
	return nil
}

func (e ExecuteToolRequest) MarshalJSON() ([]byte, error) {
	if e.Composio != nil {
		return core.MarshalJSONWithExtraProperty(e.Composio, "provider", "COMPOSIO")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", e)
}

type ExecuteToolRequestVisitor interface {
	VisitComposio(*ComposioExecuteToolRequest) error
}

func (e *ExecuteToolRequest) Accept(visitor ExecuteToolRequestVisitor) error {
	if e.Composio != nil {
		return visitor.VisitComposio(e.Composio)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", e)
}

type ExecuteToolResponse struct {
	Provider string
	Composio *ComposioExecuteToolResponse
}

func (e *ExecuteToolResponse) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Provider string `json:"provider"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Provider = unmarshaler.Provider
	if unmarshaler.Provider == "" {
		return fmt.Errorf("%T did not include discriminant provider", e)
	}
	switch unmarshaler.Provider {
	case "COMPOSIO":
		value := new(ComposioExecuteToolResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Composio = value
	}
	return nil
}

func (e ExecuteToolResponse) MarshalJSON() ([]byte, error) {
	if e.Composio != nil {
		return core.MarshalJSONWithExtraProperty(e.Composio, "provider", "COMPOSIO")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", e)
}

type ExecuteToolResponseVisitor interface {
	VisitComposio(*ComposioExecuteToolResponse) error
}

func (e *ExecuteToolResponse) Accept(visitor ExecuteToolResponseVisitor) error {
	if e.Composio != nil {
		return visitor.VisitComposio(e.Composio)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", e)
}

type IntegrationExecConfig struct {
	Type     string
	Composio *ComposioIntegrationExecConfig
}

func (i *IntegrationExecConfig) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	i.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", i)
	}
	switch unmarshaler.Type {
	case "COMPOSIO":
		value := new(ComposioIntegrationExecConfig)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		i.Composio = value
	}
	return nil
}

func (i IntegrationExecConfig) MarshalJSON() ([]byte, error) {
	if i.Composio != nil {
		return core.MarshalJSONWithExtraProperty(i.Composio, "type", "COMPOSIO")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", i)
}

type IntegrationExecConfigVisitor interface {
	VisitComposio(*ComposioIntegrationExecConfig) error
}

func (i *IntegrationExecConfig) Accept(visitor IntegrationExecConfigVisitor) error {
	if i.Composio != nil {
		return visitor.VisitComposio(i.Composio)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", i)
}

type IntegrationRead struct {
	ID       string              `json:"id" url:"id"`
	Label    *string             `json:"label,omitempty" url:"label,omitempty"`
	IconURL  string              `json:"icon_url" url:"icon_url"`
	Name     IntegrationName     `json:"name" url:"name"`
	Provider IntegrationProvider `json:"provider" url:"provider"`
	// Integration provider specific information needed for filtering tools.
	ExecConfig *IntegrationExecConfig `json:"exec_config" url:"exec_config"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (i *IntegrationRead) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IntegrationRead) UnmarshalJSON(data []byte) error {
	type unmarshaler IntegrationRead
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IntegrationRead(value)

	extraProperties, err := core.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties

	i._rawJSON = json.RawMessage(data)
	return nil
}

func (i *IntegrationRead) String() string {
	if len(i._rawJSON) > 0 {
		if value, err := core.StringifyJSON(i._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type PaginatedSlimIntegrationReadList struct {
	Count    *int                   `json:"count,omitempty" url:"count,omitempty"`
	Next     *string                `json:"next,omitempty" url:"next,omitempty"`
	Previous *string                `json:"previous,omitempty" url:"previous,omitempty"`
	Results  []*SlimIntegrationRead `json:"results,omitempty" url:"results,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *PaginatedSlimIntegrationReadList) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PaginatedSlimIntegrationReadList) UnmarshalJSON(data []byte) error {
	type unmarshaler PaginatedSlimIntegrationReadList
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PaginatedSlimIntegrationReadList(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *PaginatedSlimIntegrationReadList) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type SlimIntegrationRead struct {
	ID       string              `json:"id" url:"id"`
	Label    *string             `json:"label,omitempty" url:"label,omitempty"`
	IconURL  string              `json:"icon_url" url:"icon_url"`
	Name     IntegrationName     `json:"name" url:"name"`
	Provider IntegrationProvider `json:"provider" url:"provider"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *SlimIntegrationRead) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SlimIntegrationRead) UnmarshalJSON(data []byte) error {
	type unmarshaler SlimIntegrationRead
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SlimIntegrationRead(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SlimIntegrationRead) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type IntegrationsListRequestIntegrationProvider string

const (
	IntegrationsListRequestIntegrationProviderComposio IntegrationsListRequestIntegrationProvider = "COMPOSIO"
)

func NewIntegrationsListRequestIntegrationProviderFromString(s string) (IntegrationsListRequestIntegrationProvider, error) {
	switch s {
	case "COMPOSIO":
		return IntegrationsListRequestIntegrationProviderComposio, nil
	}
	var t IntegrationsListRequestIntegrationProvider
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IntegrationsListRequestIntegrationProvider) Ptr() *IntegrationsListRequestIntegrationProvider {
	return &i
}
